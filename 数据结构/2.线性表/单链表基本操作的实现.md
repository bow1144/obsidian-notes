> 关系的纽带是联系事物的力量 —— 爱因斯坦

### 单链表的初始化

```
// 带头节点
bool InitLIst(LinkList &L) {
	L = (LNode*) malloc(sizeof(LNode)); // 创建头节点
	L->next = NULL;
	return true;
}

// 不带头节点
bool InirList(LinkList &L) {
	L = NULL;
	return true;
}
```
> `p`是指针，则`*p`是结构体
> 可以用`p->data`，也可以用`(*p).data`

### 求表长

```
int Length(LinkList L) { // 这里是否用 & 不影响 L 的性质
	int len = 0;
	LNode *p = L;  // 表示p是一个指向 LNode 的指针
	while(p->next) {
		p = p->next;
		len++;
	}
	return len;
}
```
时间复杂度为On，注意头节点的计算

### 按序号查找节点

```
LNode *GetElem(LinkList& L, int idx) {
	LNode *p = L;
	while(p && idx--) p = p->next;
	return p;
}
```
时间复杂度为On

### 按值查找节点

```
LNode *LocateElem(LinkList& L, ElemType e) {
	LNode *p = L;
	while(p) {
		if(p->data == e) return p;
		p = p->next;
	}
	return p;
}
```
时间复杂度为On

### 插入节点操作
```
bool insertList(LinkList &L, int idx, ElemType e) {
	LNode *p = L;
	while(p && idx-- > 1) p = p->next;
	if(!p) return false;
	LNode *ins = (Lnode*) malloc(sizeof(LNode)); // 注意开节点大小
	ins->data = e;
	ins->next = p->next;
	p->next = ins;
	return true;
}
```
- 这么做是后插操作
- 如果要实现前插，只需先后插，再交换数据

### 删除节点

```
bool ListDelete(LinkList &L, int idx, ElemType &e) {
	LNode *p = L;
	while(p && idx-- > 1) p = p->next;
	if(!p || !p->next) return false;
	q = p->next;
	p->next = q->next;
	free(q);
	return true;
} 
```

### 头插法逆向建立链表

所谓头插法，就是在头后面逆向建立单链表
```
LinkList List_HeadInsert(LinkList &L) {
	LNode *s, int x;
	L = (LNode*) malloc(sizeof(LNode));
	L->next = NULL;
	scanf("%d", &x);
	while(x != 9999) {
		s = (LNode*) malloc(sizeof(LNode));
		s->next = L->next;
		L->next = s;
		s->data = x;
		scanf("%d", &x);
	}
	return L;
}
```

### 尾插法建立链表

```
LinkList List_TailInsert(LinkList &L) {
	LNode* p, int x;
	L = (LNode*) malloc(sizeof(LNode));
	L->next = NULL;
	p = L;
	scanf("%d", &x);
	while(x != 9999) {
		LNode s = (LNode*) malloc(sizeof(LNode));
		s->data = x;
		p->next = s;
		p = s;
		scanf("%d", &x);
	}
	p->next = NULL;
	return L;
}
```