对于每一趟排序：选择一个合适的增量 $d_i$
1. 类似取模的方法，将元素分为 $d_i$ 组
2. 每一组进行直接插入排序
3. 取 $d_{i+1} < d_i$，进行下一趟排序
![[{87BBB347-E23F-4501-88AF-DA1CEDEBEB49}.png]]
```
void ShellSort(ELemType A[], int n) {
	int dk, i, j;
	for(dk = n/2; dk>=1; dk/=2) { // dk序列不唯一
		for(i = dk+1; i<=n; i++) {
			if(A[i] < A[i-dk]){ // 相同于直接插入排序
				A[0] = A[i];
				for(j=i-dk; j>0&&A[0]<A[j]; j-=dk) A[j+dk] = A[j];
				A[j+dk] = A[0];
			}
		}
	}
}
```

**希尔排序的性能分析**：
- 空间复杂度为 $O(1)$
- n 在某个特定范围内，时间复杂度最低为 $O(n^{1.3})$
- 最坏时间复杂度为 $O(n^2)$
- 不稳定排序
- 仅适用于顺序表（涉及到随机存储）

---------
![[{4218DAE3-556E-4BB6-AE1F-041DB3444CAE}.png]]
A

![[{784D88DC-5A54-455D-93DE-A8001618E399}.png]]
15 20 顺序没变
B

![[{86275A5F-74FA-49E9-85E1-2D2C65EF722E}.png]]
C

![[{153682FD-B881-42C0-9396-D8A81D1A3892}.png]]
一趟4增量的排序应以10开头
A

![[{63B8DEB6-DC60-44CB-8468-0A4703CCCE37}.png]]
第一趟排序：
E E
A S
S T
Y I
Q O
U N
比较次数：6
E A S I O N E S T Y Q U
E I E Y  1 2 1
A O S Q  1 1 2
S N T U  1 1 1
比较次数：11
B

![[{9CF84543-7EDB-4964-B660-E1A3F54DCD2A}.png]]
![[{AA11649F-7624-4B7E-9419-243340E5BE5B}.png]]
第一趟：
13 9  2
24 11 77
7  56 5
1  34 
8  51
2 11 5 1 8 9 24 7 34 51 13 77 56
第二趟：
2 1 24 51 56
11 8 7 13
5 9 34 77
1 7 5 2 8 9 24 11 34 51 13 77 56
B

![[{F72B5945-8D4E-4F49-80AE-B74CC21B7F56}.png]]
A

![[{C8E2394C-661E-4322-A4AA-CF4276D62D0E}.png]]
C

![[{2F2796D9-4157-47D1-8BF2-5223A7BE2069}.png]]
9 13 20 有序，增量应该为3
B

![[{F74FFCFF-9CCA-4D82-BEC0-6DFEDD287052} 1.png]]
A

![[{3B6C3DD9-1EEC-4205-B7BE-E0D06348CFE8}.png]]
第一趟：5
第二趟：3和2交换，3
D