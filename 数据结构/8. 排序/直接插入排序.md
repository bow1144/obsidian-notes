**直接插入排序的思想**：将序列分为**已处理序列，正处理元素`L(i)`，未处理序列**：
**直接插入排序的操作**：
1. 查找`L(i)`在**已处理序列**中的位置
2. 将已处理序列的元素整体后移
3. `L(i)`复制到对应位置
```
void InsertSort(ElemType A[], int n) {
	for(int i=2; i<=n; i++) {
		if(A[i] < A[i-1]) {
			A[0] = A[i];    // A[0] 不存储元素，作为哨兵使用
			for(int j=i-1; A[0]<A[j]; j--) A[j+1] = A[j];
			A[j+1] = A[0];
		}
	}
}
```

**直接插入排序的性能分析**：
- **空间复杂度**：仅使用了常数个辅助单元，空间复杂度为 $O(1)$
- **时间复杂度**：
	- 最好情况下，元素已经排序，$O(n)$
	- 最坏情况下，逆序，比较次数最大，$O(n^2)$
- **稳定性：稳定**
- 适用于顺序存储和链式存储，适用于**基本有序**的序列

--------
![[{7F7A8DB7-0511-4857-9580-62C78E6C69F9}.png]]
第二个元素：一次；第五个元素：四次
$k=\frac{n(n-1)}{2} = 10$
B

![[{4EDD78FF-3BBF-4B2F-AF85-ED98FD2D15DE}.png]]
A

![[{D0B9D7A3-DECB-4E8F-8B05-8AAE7C87191E}.png]]
信息：基本有序
B

![[{3559A031-9B89-40C6-A0E8-AEBCC927AC3B}.png]]
DA

![[{34F24B90-2E11-422B-95F6-CDFC36F9DBCC}.png]]?
*冒泡，选择，堆排序在排序中能形成全局有序的子序列*
*C*

![[{277C0B87-24FC-4A06-A67D-860F09783009}.png]]
应该是B，基本有序

![[{71A7D51D-C030-4643-8E7E-80D221057223}.png]]
C

![[{4D817298-88E7-4FB8-9090-C79D06C5A6F4}.png]]
C
