折半查找又称二分查找，静态查找，仅适用于有序的顺序表

**折半查找的思想**：
1. 将 key 与中间值比较，成功则返回存储位置
2. 不等，则只在**中间元素以外**的左半或右半查找
```
int Binary_Search(SSTable L, ElemType key) {
	int low = 0, high = L.TableLen-1, mid;
	while(low <= high) {
		mid = (low + high) / 2;
		if(L.elem[mid] == key) return mid;
		else if(L.elem[mid] > key) high = mid - 1;
		else low = mid + 1;
	}
	return -1;
}
```

**折半查找与二叉树**：
- 称之为判定树，是一颗平衡树
- 有 n 个圆形结点和 n+1 个方形结点（失败）
- 折半查找的最多次数不超过树高
- $ASL = \frac{n+1}{n} \log_2(n+1)-1 \approx \log_2(n+1)-1$
![[{0E62DA0F-F935-48C9-9D95-6D6F67B00422}.png]]

------------
![[{8843AAD8-C781-4841-9C46-C06A150FC81D}.png]]
![[{968D694D-0236-4DF9-A0A3-69AC02694A0F}.png]]
A，不能是链式存储
B，不限制类型
C，不限制顺序
D

![[{E86276FC-EA28-4400-BAB8-CEBA48556FE0}.png]]
C

![[{1B48A772-4DF6-45F2-A1A2-F2331AEC96D9}.png]]
B，必然是平衡二叉树

![[{3C39CB07-322B-40A7-8F3D-85A4F353DD8D}.png]]
折半查找和二叉搜索树时间性能等价
~~A~~
*二叉搜索树是平衡二叉树，二叉排序树不一定是平衡树*
*B*

![[{393FD58F-8E86-4283-BDB2-206DF38E6B57}.png]]
注意中间元素不参与下一次比较
6，9，10，11
B

![[{D1FB3510-AD84-4D3E-8537-B112CE60F6B1}.png]]
50，90
B

![[{D7270A0D-5F1E-4D0C-A41B-A0A3C7EC93D6}.png]]
f, c, b
A

![[{050F783D-C1B1-4928-B932-FAB80DA69E6E}.png]]
A 

![[{DC639806-0F22-41D6-82DA-5C3240DECA9F}.png]]
一共有4~5层，最少4次，最多5次
AB
*比较次数和树高相同*

![[{C5C5B6AD-5905-48A6-924F-0A6C69143E03}.png]]
树高：3~4
*可以计算每个元素的概率和长度*
*成功：* $(ASL = 1+2*2+3*4+4*5) / 12 = 37/12$
*失败：* $(ASL = 3*3 + 4*10) / 13 = 49/13$
*AD*
![[{A2B9445F-2CA9-42BA-8119-D18BC6485FAF}.png]]

![[{0CEB51FB-7E02-48AB-83DC-2C46638D8954}.png]]D，不会
*A，不仅要求有序，还要顺序存储*
*B，二叉查找树不一定是平衡树*

![[{68B5DB75-50E7-4EE0-8E91-8012C8C04847}.png]]
层数为 4~5，最多比较次数为 5
B

![[{FA288542-2911-43C3-81B4-763872E96E70}.png]]
A，在200后出现了比200大，小的key

![[{D5C87BBA-D547-4BD0-82E2-7DF6D164FDFC}.png]]类似分块为3的分块查找
B

![[{FF58A41A-FF32-42C2-A591-1AC7A230BB87}.png]]
*有 $mid = \lfloor (low+high)/2 \rfloor or \lceil (low+high) \rceil$*
*对于前者，左子树结点等于或者少右子树结点一个*
*对于后者，相等或多一个*
*不能出现既多一个右少一个的时候*
*A*

![[{EF8ED513-4B3F-4242-B2D6-C5011ABDD5A8}.png]]
最多比较 $\log(n+1) = 9$
~~A~~
*公式是 $\lceil \log(n+1) \rceil = 10$*
*或者可以比较树高*
*B*