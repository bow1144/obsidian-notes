### BTree 的插入

1. **定位**：利用BTree查找算法，找到失败结点
2. **插入**：非根结点关键字个数在 $[\lceil m/2 \rceil-1, m-1]$，如果插入后结点小于等于上限，可以直接插入，否则必须对结点**分裂**
3. **分裂**：从中间位置 $\lceil m/2 \rceil$ 将关键字表分成左右两部分，左边放在原结点，右边放在新结点，中介按位置的结点插入父节点；如果父结点也溢出则继续分裂
![[{1D1BCACB-3BDB-4592-ADFA-A7EAFC374714}.png]]

### BTree 的删除

1. 关键字不在终端结点：用左子树的最右下元素替代 k，最终转化成关键字在终端结点的情况
2. **关键字在终端结点**：
	1. 删除前结点个数**大于等于** $\lceil m/2 \rceil$ ：不用合并，直接操作
	2. **兄弟够借**：删除前卡在下限，兄弟结点不在下限，向右（左）兄弟借一个
		1. 以右兄弟为例，右节点的最小换到父节点
		2. 父节点换到删除的结点的位置
	3. **兄弟不够借**：删除结点，父节点关键字下放到兄弟
![[{61DFF8DA-B260-4494-93E9-97962654C69C}.png]]

----------
![[{594B1672-99AD-4F6B-BDF9-4F52C21E671B}.png]]
插入分裂的条件：插入前达到上限 m-1
删除合并的条件：删除前达到下限
B

![[{67D62546-177E-4256-836C-3A52F8F71F58}.png]]
1. 这是3阶BTree，删除78后突破下限，需要合并操作
2. 左兄弟有两个关键字，可以借兄弟的
3. 65下放到78的位置，62上移到65的位置
D

![[{DB1100B9-62FB-4448-82C3-80D3A38C47A3}.png]]
漕，完全不会
*4阶BTree的关键字上限：3*
![[{198D4C14-CA6E-4FFD-8953-80CB1A3666E3}.png]]

![[{19B3B666-5EB8-4D7C-BDBA-D5101FEFEEA1}.png]]
- 不在叶子结点：260 被 110/280 替代，现在要处理 110/280 被删除的情况
- 100 需要寻求合并
	- 向左合并：90变85，对应C
	- 向右合并：兄弟不够借，110/280下放，对应B