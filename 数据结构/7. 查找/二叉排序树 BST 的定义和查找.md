**二叉排序树的特性**：
- 左子树的子节点全部小于根节点
- 右子树的子节点全部大于根节点
- 二叉排序树**可以不是**平衡树

**BST 的目的**：
- 加快查找，插入，删除

**BST 的查找**：
- 递归查找，退出条件是没有子节点或者找到
```
BSNode *BST_Search(BiTree, ElemType key) {
	while(T && key!=T->data) {
		if(key < T->data) T = T->left;
		else T = T->right;
	}
	return T;
}
```

**BST 的查找效率**：查找效率取决于树高
- 若 BST 是线性结构，平均查找长度为 $O(n)$
- 若 BST 是平衡二叉树，平均查找长度为 $O(\log_2n)$
- 维护表的平均时间为 $O(\log_2n)$

------------
![[{FD2B86CB-D5D8-4AB1-BB2E-86C57BC87BDA}.png]]
A，二叉排序树不是动态书
C，是这样的
D，错误的，可能只有一个结点
C

![[{682FD52A-9162-46C2-8164-0EA9ED94BFDB}.png]]
左小于中，右大于中，左中右，中序
B

![[{8D1EB0BE-D4B0-4B0E-929B-8F1846C87DBE}.png]]
效率只与 n 有关
B？

![[{096D4450-B271-4431-9FA2-16D4B3229D6B}.png]]
右指针为空
B

![[{D299FC0B-1B27-4304-9950-88460C75D784}.png]]
C，不可能，911后有大有小

![[{9170B81C-0971-44F9-BFA5-79044E2E290C}.png]]
C，100 的左孩子是 80

![[{3713B2DD-357E-4099-A6ED-6447013E5A38}.png]]
60 比 52 大，比 71 小
A

![[{1DEBE1E7-281F-4BEA-92B0-CBB701CC1450}.png]]二叉排序树可能是线性的，D

![[{679816E5-D299-4FD9-9576-7E8874649E7A}.png]] 
两个结点的查找树：2
三个结点的查找树：2+1+2=5
四个结点的查找树：5+2+2+5=14
五个结点的查找树：14+5+(2+2)+5+14=42
*也可以用卡特兰数计算*

![[{E6562269-05CD-45CC-A57A-5923DAC4E77E}.png]]
理想情况下是 log
D