- 四种遍历序列的任意一种都无法构造唯一二叉树
- 但**中序序列**和三种中的任意一种都可以构造唯一二叉树
- 由序列构造二叉树是一个递归过程
- 核心是**用根节点分割中序序列为左右子树**

![[{3465DD3B-6BB8-4847-B3E3-E5DBCD8FBB89}.png]]![[{0043D565-EBDD-4DE8-88BB-DF7DE6FB30DF}.png]]

-----

![[{1A802CC2-F8F2-415A-A998-DB5B42D35F41}.png]]
B
对于选项，可以按根节点左右分，通过先序、中序构造二叉树
如果在递归中发现**先序、中序序列不匹配**的情况可以认为不可能构造

![[{128733B0-EAF2-4C9C-9CAA-0A678AD5AAE3}.png]]
1. 先确定根节点为C，结点都在左边
2. 左子树根节点为E，左边是D，右边是BA
3. 前三个为CED，
D

![[{730130EB-085F-4479-9921-85C6EA9A54AC}.png]]
1. 先确定根节点为A，左为CB，右为EDF
2. 二者BC顺序不一样-》BC是中左关系-》C是B的左儿子-》后序开始是CB
3. 右子树的根节点是D，EF顺序相同，EF是D的左右儿子
4. 右子树的后序遍历是EFD
5. 整体后序遍历为 CBEFDA
A

![[{4A4746D1-90C3-48F1-BEC4-3BC01C01D487}.png]]
1. 根节点为 A，有左节点 B，右子树是 DCFE
2. 右子树的根节点是C
B

![[{5DF5705D-9B35-402D-84A6-286513D555CC}.png]]
C，中序遍历后代没有固定顺序
*B：后序遍历中后代一定在祖先前面*


![[{5A4BDEC7-56C2-47FE-9320-6B4BE0032F84}.png]]
中左右和左右中没有相同的序列：所有结点分散在四行
C

![[{F459AE6F-587E-496B-A1D6-5BC9121EBE43} 1.png]]
1. 根节点是 a
2. 由后序遍历：a肯定有孩子e
3. 又e是前序第二个结点
4. 故孩子结点只有e

![[{1C149735-46F2-41A9-946E-AC63C80C9745}.png]]
- 排列一：分四层，有 $2^{4-1} = 8$ 种
- 排列二：分三层（b 必在第二层）
	- bc在第二层：2
	- bd在第二层：2
	- b在第二层：2
14种

*题目抽象：前序入栈中序出栈，求中序出栈的排列数*
*对 n 给不同元素进栈，出栈个数为 Catalan(n)*

![[{3E7C7B08-C3B8-4DB4-B882-A2E35E1A0F8D}.png]]
B

![[{B85BE81A-1EEA-4E97-A10D-962DC1DE5017}.png]]
中左右和左中右相同：没有中（非空，排除）或者没有左结点
B

![[{EFEB4DCA-3808-4C2C-971F-BE4B401F77EE}.png]]
p是q的中序前缀：
- p是q的左子结点
- q是p的右子节点
- q是p的祖先
B

![[{CE5E2D47-017A-41BE-97E0-31D82749FF05}.png]]
aedfbc
A