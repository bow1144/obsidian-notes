
并查集是一种集合表示，有三种基本操作：
- `Initial(S)`将集合 S 初始化
- `Union(S, Root1, Root2)`：将两个集合合并，但两个集合不能有相交
- `Find(S)`：查找集合S中 x 所在的子集合，返回子集和的根节点

**并查集的存储结构**：
- 全集合初始化为一个森林，每棵树只有一个结点
- 使用结点的双亲表示，初始时每个结点的双亲设置为 -1
- 并：将一个集合的根节点作为另一个结点的根节点的儿子
- 查：迭代查找结点的双亲，直到找到并返回根节点

**并查集的基本实现**：
```
void Initial(int S[]) {
	for(int i=0; i<S.size(); i++) S[i] = -1;
}

void Union(int S[], int Root1, int Root2) {
	if(Root2 == Root1) return; // 同一个集合不能合并
	S[Root2] = Root1; // 设置 Root2 的双亲为 Root1
}

int Find(int S[], int x) {
	while(S[x] >= 0) x = S[x];
	return x;
}
```

--------------------------
![[{45ABFA07-31A0-4B32-9440-6D690C93813D}.png]]
B

![[{211669EA-852B-4C5B-9B68-FB8F1E5DD21E}.png]]
一开始有 10 个集合
8 步操作中有 7 步是合法的
C

![[{BD45D142-F997-477E-9FBC-BD1BA94BC6EF}.png]]
A、并查集可以找回路
B、否，路径优化后压缩到 log
C、~~前半句是的，一开始是 -1，但是不能作为标志？~~*find操作总返回根节点*
D、是的

![[{B4330ECC-5440-4862-BAEC-0549C7D140C5}.png]]
A、B、C 都是正确的
优化前的 find 是 n，优化后近似常数
D

