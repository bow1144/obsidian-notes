
以斐波那契数量为例：
```
int F(int n) {
	if(n <= 1) return n;
	else return F(n-1) + F(n-2);
}
```

- 栈中存储待计算的值，例如一开始的`F(4)`，调用`F(3), F(2)`
- 依次入栈`F(4),F(3),F(2)`
- 最后从顶到底返回

--------
![[{A3543F59-BDAD-4031-8D3E-F38419070844} 1.png]]
f(1) = 1 * f(0) = 1 * 2 = 2
f(2) = 2 * f(1) = 2 * 2 = 4

![[{5B3792CE-4D50-4B12-B651-90D3FA3ACF22}.png]]
`F(8) = F(6) + F(4) + 1 = F(4)+F(2)+1 + F(2)+F(0)+1 = 3*F(2) + 2*F(0) + 3 = 8
~~B~~
*第一轮：1（8）；第二轮：2（6，4）；第三轮 4（4，2，2，0），第四轮（2，0）*
*求递归次数要用递归树*

![[{389B249F-3D05-463A-8C07-8A4ABA0BCACA}.png]]
1. func 5
2. func 3
3. func 1 // func 5 = 4
4. func 4
5. func 2
C

![[{C7A0E127-E5D9-4072-9A84-D0E28ECE5CDA}.png]]
~~D（吧）~~
*B，通常，二者有优劣之分*

![[{79F69A90-CE0D-4131-B399-EA2E833466FC}.png]]
C，局部变量存储在栈中

![[{0C25E63B-D311-41CF-B187-B006231973AC}.png]]
A

![[{F3E56040-77FC-4C0C-AC9F-8133A41ADB31}.png]]
C，1不确定*斐波那契数列只用循环*