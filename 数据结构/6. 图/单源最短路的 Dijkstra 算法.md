Dijkstra 算法的核心思想：贪心，逐步扩大路径树
1. **初始化**：源节点距离设置为0，其它结点距离设置为无穷大，进行松弛
2. **选择最小结点**：从未确定的结点中选择距离最小的结点，标记为已确定
3. **松弛操作**：通过该结点更新邻接结点的距离
4. **循环**：重复上述步骤，直到所有节点的最短路劲都被确定

- Dijkstra 算法的时间复杂度是 $O(|V|^2)$
- Dijkstra 与 Prim 算法的区别
	- 目的不同
	- 使用的图不同：Dijkstra 算法适用带权有向图和带权无向图，Prim算法只适用于带权无向图
- Dijkstra 算法不能处理有负权边的情况

--------
![[{73A3835D-6271-407B-8C78-3ECE065EB917}.png]]
A，不一定，对于负权环来说并非*最短路径一定是简单路径，原话*
B，否，只是不适合负权环
C，正确，只能求单源最短路，*适合，并非只能*
D，不明白，但应该不是*明白了，k就是中间结点*
*A*

![[{2DDDBF07-8C4A-489C-9F4F-1FF8ABE48ED3}.png]]
I，Dijkstra 算法和 Floyd 算法的主要区别是不处理负权值的图，正确
II，正确的*题目中是”每对顶点，一共要有n次*
III，正确的
A

![[{D8FC18E6-5B58-49A0-BB35-ED26CDDCAB05}.png]]![[{7A109C7C-4DAA-4ABF-AAD1-1ACDA899F4F8}.png]]
没有负权边，特定点对，适用 Dijkstra 算法
1. v1，v3
2. v1，v3，v4
3. v1，v3，v4，v5
4. v1，v3，v4，v5，v7
~~C~~
*每次选择结点之后，要对其邻接结点松弛*
*B*

![[{D5A6A16F-811D-4735-A3E1-B0956BDC147D}.png]]
选取目标结点为1，则更新与1相关的
D

![[{93693C99-515B-40C7-97F7-FC8096E7BE59}.png]]
f，d，e
C

![[{2F924709-76F6-493C-9543-7B7C18D0575C}.png]]

|     | 1   | 2     | 3     | 4   | 5     | 6     |
| --- | --- | ----- | ----- | --- | ----- | ----- |
| 1   |     | 5     |       |     | **4** |       |
| 2   |     | **5** |       |     |       | 9     |
| 3   |     |       | **7** | 14  | 4     | **9** |
| 4   |     |       |       |     |       |       |
| 5   |     |       |       |     |       |       |
5 2 3 6 4
B 

![[{820334F5-FB54-43A6-82C7-06BE7C18402F}.png]]

|     | 1   | 2   | 3     | 4   | 5     |
| --- | --- | --- | ----- | --- | ----- |
| 1   |     | 26  | **3** |     | 6     |
| 2   |     | 25  |       |     | **6** |
| 3   |     | 21  |       | 14  |       |
|     |     |     |       |     |       |
在求出第二条最短路后，还要进行**松弛**
21 3 14 6