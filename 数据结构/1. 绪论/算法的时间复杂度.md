> 一个好的算法，不仅要正确，还要快 —— 冯·诺伊曼

- 算法的基本运算是**循环中最深的语句**
- $T(n)$是算法规模$n$的函数，时间复杂度分析$T(n)$的数量级$O(n)$
- 一般总是分析最差情况
* 加法规则：加法下取最大者
* 乘法规则：相乘即可

* 简单情况下直接分析，复杂情况带值计算或列式计算

----
![[{3F880DBC-288E-4C16-9CCB-3551CF436562}.png]]
C，执行时间与$n^2$正比

![[{3669EDD3-0198-425E-8E23-09A16E559BEF}.png]]
D，只需比较最大项

![[{56E6ADA1-6C5D-416C-A6FF-AC903F268598}.png]]
D，循环次数为对数

![[{20BF73E4-9306-46ED-A749-453518BA608B}.png]]
![[{9BF84B9F-59D0-47F6-9AE6-4C5C21B1245E}.png]]
C，循环次数为立方根

![[{5F0C939E-42C3-4A74-B79B-5D887AE0FC6E}.png]]
D，循环次数为n，n/2

![[{AAB02982-230F-4980-AEB5-8DE905AF3D9B}.png]]
A，最大循环次数为$n^2$

![[{338AF78E-9EB7-448B-9AB0-FD4624ECECA1}.png]]
~~D，第一层循环次数为n，第二层为$\frac{2*n}{2}$~~
*第一层循环次数为n，第二层为$\frac{n(n+1)}{2}$*
*在时间复杂度中，第二层可以约为n/2，但千万不能无脑约，一是一二层的连接可能会有特殊意义，而是题目是求**执行次数**而非时间复杂度**

![[{41D51BD0-EF13-4E3A-8800-55BC5BA3F5B1}.png]]
C，简单递归，每次n减半

![[{D4910E31-0761-4B0C-A9CA-D1ACFA93DE82}.png]]
A，循环次数为对数级

![[{69AD4BD2-0601-4880-863A-8A809AB63676}.png]]
B，简单递归，递归次数为n

![[{22949A34-482C-49A5-8295-8836FB321BB2}.png]]
![[{FAA2913E-F497-49A9-88C5-A8BC7DAB4CA0}.png]]
C，第一层是对数，第二层是n

![[{4014CF09-CCB3-45E2-97A2-A4D1DA8884D3}.png]]
B，累加的公式是$\frac{n(n+1)}{2}$，逆运算就是根号

![[{2E4BE27B-B77F-4A60-8994-A03ECF064045}.png]]
B，循环次数为根号级

![[{2446C84D-EB35-471F-9E53-2398F0C7C453}.png]]
C，第一层是对数级，第二层是n/2
*一二层可以结合，单元语句的执行次数为 1+2+4...+2^(t-1)，t=log(n)，故时间复杂度为n*
$$ 2^0 + 2^1 + 2^2 +...+ 2^{\log n} = 2^{\log n+1}-1 \approx n$$
*或者可以直接取$n=1024$，得到底层执行次数1+2+4+8...+512=1024-1*

*总结：注意题目给的是时间复杂度还是**执行次数**，后者要精确计算*
*在**一二层变量关联**是，不能无脑相乘，最好列式计算或带值计算**